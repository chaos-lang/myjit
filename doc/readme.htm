<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

body {
       font-family: sans-serif;	
       font-size: 10pt;
       margin-left: 10%;
       margin-right: 10%;
       background: white;
}

.title {
	font-size: 18pt;
}

h1 {
	color: #aa0000;
	font-size: 16pt;
	padding-bottom: 3pt;
	margin-top: 20pt;
	border-bottom: 1px solid #aa0000;
}

h2 {
	margin-top: 20pt;
	font-size: 13.5pt;
	color: #aa0000;
}

h3 {
	margin-top: 13pt;
	padding-top 0pt;
	font-size: 11.5pt;
	color: #aa0000;
	padding-bottom: 0px;
	margin-bottom: 0px;
}



pre, .pre, tt {
	color: #333333;
}

h3 tt {
        color: #aa0000;
}


a {
	color: #007700;
	text-decoration: none;
}

a:hover {
	color: #007700;
	text-decoration: underline;
}

hr {
	color: #aa0000;
	background-color: #aa0000;
	border: 0px;
	height: 1px;
}

.highlight {
	padding-top: 0px;
	padding-bottom: 0px;
	padding-left: 0px;
	padding-right: 0px;
	background: white;
	/*border: 1px solid #aa0000;*/
}
.hll { background-color: #ffffcc }
.comment { color: #408080; /* font-style: italic*/ } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.preproc { color: #BC7A00 } /* Comment.Preproc */
.single { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.keyword { color: #008000; font-weight: bold; } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.type { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.function { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.operator { /*color: #AA22FF;*/ /*font-weight: bold*/ } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.integer { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.string { color: #BA2121 } /* Literal.String.Char */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.escape { color: #BB6622;/* font-weight: bold */} /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
</head>
<body>
<div class="document">


<div class="section" id="myjit">
<h1>MyJIT</h1>
<p>MyJIT is a library that allows to generate machine code at run-time and afterwards execute it. The project has started as a part of the Just-in-Time compiler of the Schemik (<a class="reference external" href="http://schemik.sourceforge.net">http://schemik.sourceforge.net</a>) programming language and as a replacement for the GNU lightning library (<a class="reference external" href="http://www.gnu.org/software/lightning/">http://www.gnu.org/software/lightning/</a>) fixing some of its design issues. However, it has evolved into a more powerful tool. Therefore, MyJIT has a very similar instruction set as GNU lightning but it differs in some key aspects. The most important features which make MyJIT different or which should be highlighted are:</p>
<ul class="simple">
<li>support for an unlimited number of registers</li>
<li>thread-safety</li>
<li>support for the i386, AMD64, and SPARC processors</li>
<li>convenient debugging</li>
<li>easy to use and easy to extend design</li>
<li>support for optimizations</li>
<li>the library is fully embeddable</li>
<li>particular backward compatibility with GNU lightning</li>
</ul>
</div>
<div class="section" id="instruction-set">
<h1>Instruction Set</h1>
<p>The instruction set of the MyJIT intermediate language is inspired by GNU lightning and in some aspects resembles architecture of RISC processors. Each operation has up to four operands which can be immediate values (numbers, constants) or registers. The number of available registers is virtually unlimited.</p>
<p>All general purpose registers and integer values are treated as signed integers and have the same size which corresponds to the register size of the CPU. Note that i386 and SPARC processors have 32 bit wide registers and AMD64 has 64 bit wide registers.  In order to overcome this inconsistency, MyJIT provides the <tt class="docutils literal">jit_value</tt> type which has the same size as the CPU's general purpose register. In specific cases, e.g., if smaller or <tt class="docutils literal">unsigned</tt> value is needed and it is appropriate, you may specify the size or type of the value. This topic is discussed later.</p>
<p>All floating-point numbers and registers are internally treated as double precision values. However, if necessary, the value can be converted into a single precision value.</p>
<p>Typically, name of each instruction consists of three parts:</p>
<ul class="simple">
<li>name of the operation (e.g., <tt class="docutils literal">add</tt> for addition, <tt class="docutils literal">mul</tt> for multiplication, etc.)</li>
<li>the name of the operation is often accompanied with the suffix <tt class="docutils literal">r</tt> or <tt class="docutils literal">i</tt> indicating whether the operation is taking merely registers or if it also takes an immediate value as its argument</li>
<li>name of the operation can be equipped with additional flag delimited by the underscore (typically, this is used to identify operations handling unsigned numbers)</li>
</ul>
<div class="section" id="registers">
<h2>Registers</h2>
<p>MyJIT supports arbitrary number of register. If the number of used registers is higher than the number of available hardware registers, MyJIT emulates them. Nevertheless, to achieve the best performance, it is a good practice not to use too many registers. All registers are denoted by positive integers including zero. To refer to these registers you should use macros <tt class="docutils literal">R(x)</tt> and <tt class="docutils literal">FR(x)</tt> identifying general purpose and floating point registers, respectively. Note that registers <tt class="docutils literal">R(x)</tt> and <tt class="docutils literal">FR(x)</tt> are completely different register and do not occupy the same space.</p>
<p>Besides, MyJIT has two special purpose registers---R_FP and R_OUT. R_FP serves as the frame pointer and is used to access dynamically allocated memory on the stack. The R_OUT can be used to handle the return values more efficiently. It can be used to read the return value right after the return from the function. Otherwise, the value of the register is undefined. Furthermore, it can be used right before the return from the function to set the return value more efficiently. If the value is set earlier, it can lead to undefined behavior. However, in most cases register allocator can optimize this which makes this register almost obsolete.</p>
</div>
<div class="section" id="notation">
<h2>Notation</h2>
<p>In order to describe instruction set, we are using symbols <tt class="docutils literal">reg</tt> and <tt class="docutils literal">freg</tt> to denote general purpose and floating-point registers, respectively. Analogously, <tt class="docutils literal">imm</tt> and <tt class="docutils literal">fimm</tt> denote immediate integer values and floating-point values. Particular instructions (e.g., load and store operations) have an extra operand which specifies the size (number of bytes) of data they work with. This operand shall be denoted by <tt class="docutils literal">size</tt> and <tt class="docutils literal">fsize</tt>. The value passed by the operand <tt class="docutils literal">size</tt> can be 1, 2, 4, or 8. However, only the AMD64 port supports operation processing 8 bytes long values. The value passed by the operand <tt class="docutils literal">fsize</tt> can be either 4 or 8. In other words, <tt class="docutils literal">fsize</tt> denotes precision of the value.</p>
</div>
<div class="section" id="instructions">
<h2>Instructions</h2>
<div class="section" id="transfer-operations">
<h3>Transfer Operations</h3>
<p>These operations allow to assign a value into a register. The first operand is always a register and the second one can be either an immediate value or register.</p>
<pre class="literal-block">
movi  reg, imm          O1 := O2
movr  reg, reg          O1 := O2

fmovr freg, freg        O1 := O2
fmov  freg, fimm        O1 := O2
</pre>
</div>
<div class="section" id="binary-arithmetic-operations">
<h3>Binary Arithmetic Operations</h3>
<p>Each binary arithmetic operation has exactly three operands. First two operands are always registers and the last one can be an immediate value or register. These operations are fully compatible with those in the GNU lightning instruction set.</p>
<pre class="literal-block">
addr   reg, reg, reg      O1 := O2 + O3
addi   reg, reg, imm      O1 := O2 + O3
addxr  reg, reg, reg      O1 := O2 + (O3 + carry)
addxi  reg, reg, imm      O1 := O2 + (O3 + carry)
addcr  reg, reg, reg      O1 := O2 + O3, set carry
addci  reg, reg, imm      O1 := O2 + O3, set carry

subr   reg, reg, reg      O1 := O2 - O3
subi   reg, reg, imm      O1 := O2 - O3
subxr  reg, reg, reg      O1 := O2 - (O3 + carry)
subxi  reg, reg, imm      O1 := O2 - (O3 + carry)
subcr  reg, reg, reg      O1 := O2 - O3, set carry
subci  reg, reg, imm      O1 := O2 - O3, set carry
rsbr   reg, reg, reg      O1 := O3 - O2
rsbi   reg, reg, imm      O1 := O3 - O2

mulr   reg, reg, reg      O1 := O2 * O3
muli   reg, reg, imm      O1 := O2 * O3
hmulr  reg, reg, reg      O1 := high bits of O2 * O3
hmuli  reg, reg, imm      O1 := high bits of O2 * O3

divr   reg, reg, reg      O1 := O2 / O3
divi   reg, reg, imm      O1 := O2 / O3
modr   reg, reg, reg      O1 := O2 % O3
modi   reg, reg, imm      O1 := O2 % O3

andr   reg, reg, reg      O1 := O2 &amp; O3
andi   reg, reg, imm      O1 := O2 &amp; O3
orr    reg, reg, reg      O1 := O2 | O3
ori    reg, reg, imm      O1 := O2 | O3
xorr   reg, reg, reg      O1 := O2 ^ O3
xori   reg, reg, imm      O1 := O2 ^ O3

lshr   reg, reg, reg      O1 := O2 &lt;&lt; O3
lshi   reg, reg, imm      O1 := O2 &lt;&lt; O3
rshr   reg, reg, reg      O1 := O2 &gt;&gt; O3
rshi   reg, reg, imm      O1 := O2 &gt;&gt; O3
rshr_u reg, reg, reg      O1 := O2 &gt;&gt; O3  (unsigned variant)
rshi_u reg, reg, imm      O1 := O2 &gt;&gt; O3  (unsigned variant)
</pre>
<p>Operations <tt class="docutils literal">subx</tt> and <tt class="docutils literal">addx</tt> have to directly follow <tt class="docutils literal">subc</tt> and <tt class="docutils literal">addc</tt> otherwise the result is undefined. Note that you can use the <tt class="docutils literal">unsigned</tt> flag with the <tt class="docutils literal">rshr</tt> operation to propagate the first bit accordingly.</p>
<p>There are also equivalent operations for floating-point values.</p>
<pre class="literal-block">
faddr   freg, freg, freg      O1 := O2 + O3
faddi   freg, freg, fimm      O1 := O2 + O3
fsubr   freg, freg, freg      O1 := O2 - O3
fsubi   freg, freg, fimm      O1 := O2 - O3
frsbr   freg, freg, freg      O1 := O3 - O2
frsbi   freg, freg, fimm      O1 := O3 - O2
fmulr   freg, freg, freg      O1 := O2 * O3
fmuli   freg, freg, fimm      O1 := O2 * O3
fdivr   freg, freg, freg      O1 := O2 / O3
fdivi   freg, freg, fimm      O1 := O2 / O3
</pre>
</div>
<div class="section" id="unary-arithmetic-operations">
<h3>Unary Arithmetic Operations</h3>
<p>These operations have two operands, both of which have to be registers.</p>
<pre class="literal-block">
negr  reg      O1 := -O2
notr  reg      O1 := ~O2
fnegr freg     O1 := -O2
</pre>
</div>
<div class="section" id="load-operations">
<h3>Load Operations</h3>
<p>These operations transfer data from the memory into a register. Each operation has 3 or 4 operands. The last operand is an immediate value indicating the &quot;size&quot; of the data processed by this operation, i.e., a number of bytes copied from the memory to the register. It can be one of the following values: 1, 2, 4, or 8. Furthermore, the <tt class="docutils literal">size</tt> cannot be larger than the size of the register. If the size of the data copied from the memory is smaller than the size of the register, the value is expanded to fit the entire register. Therefore, it may be necessary to specify additional sign flag.</p>
<pre class="literal-block">
ldr      reg, reg, size             O1 := *O2
ldi      reg, imm, size             O1 := *O2
ldr_u    reg, reg, size             O1 := *O2         (unsigned variant)
ldi_u    reg, imm, size             O1 := *O2         (unsigned variant)

ldxr     reg, reg, reg, size        O1 := *(O2 + O3)
ldxi     reg, reg, imm, size        O1 := *(O2 + O3)
ldxr_u   reg, reg, reg, size        O1 := *(O2 + O3)  (unsigned variant)
ldxi_u   reg, reg, imm, size        O1 := *(O2 + O3)  (unsigned variant)

fldr     freg, reg, fsize           O1 := *O2
fldi     freg, imm, fsize           O1 := *O2

fldxr    freg, reg, reg, fsize      O1 := *(O2 + O3)
fldxi    freg, reg, imm, fsize      O1 := *(O2 + O3)
</pre>
</div>
<div class="section" id="store-operations">
<h3>Store Operations</h3>
<p>These operations transfer data from the register into the memory. Each operation has 3 or 4 operands. The last operand is an immediate value and indicates the &quot;size&quot; of the data, see &quot;Load Operations&quot; for more details. The first operand can be either an immediate or register. Other operands must be registers.</p>
<pre class="literal-block">
str     reg, reg, size              *O1 := O2
sti     imm, reg, size              *O1 := O2

stxr    reg, reg, reg, size         *(O1 + O2) := O3
stxi    imm, reg, reg, size         *(O1 + O2) := O3

fstr    reg, freg, fsize            *O1 := O2
fsti    imm, freg, fsize            *O1 := O2

fstxr   reg, reg, freg, fsize       *(O1 + O2) := O3
fstxi   imm, reg, freg, fsize       *(O1 + O2) := O3
</pre>
</div>
<div class="section" id="compare-instructions">
<h3>Compare Instructions</h3>
<p>These operations compare last two operands and store one or zero (if the condition was met or not, respectively) into the first operand. All these operations have three operands. The first two operands have to be registers and the last one can be either a register or an immediate value.</p>
<pre class="literal-block">
ltr    reg, reg, reg      O1 := (O2 &lt;  O3)
lti    reg, reg, imm      O1 := (O2 &lt;  O3)
ltr_u  reg, reg, reg      O1 := (O2 &lt;  O3)  (unsigned variant)
lti_u  reg, reg, imm      O1 := (O2 &lt;  O3)  (unsigned variant)

ler    reg, reg, reg      O1 := (O2 &lt;= O3)
lei    reg, reg, imm      O1 := (O2 &lt;= O3)
ler_u  reg, reg, reg      O1 := (O2 &lt;= O3)  (unsigned variant)
lei_u  reg, reg, imm      O1 := (O2 &lt;= O3)  (unsigned variant)

gtr    reg, reg, reg      O1 := (O2 &gt;  O3)
gti    reg, reg, imm      O1 := (O2 &gt;  O3)
gtr_u  reg, reg, reg      O1 := (O2 &gt;  O3)  (unsigned variant)
gti_u  reg, reg, imm      O1 := (O2 &gt;  O3)  (unsigned variant)

ger    reg, reg, reg      O1 := (O2 &gt;= O3)
gei    reg, reg, imm      O1 := (O2 &gt;= O3)
ger_u  reg, reg, reg      O1 := (O2 &gt;= O3)  (unsigned variant)
gei_u  reg, reg, imm      O1 := (O2 &gt;= O3)  (unsigned variant)

eqr    reg, reg, reg      O1 := (O2 == O3)
eqi    reg, reg, imm      O1 := (O2 == O3)

ner    reg, reg, reg      O1 := (O2 != O3)
nei    reg, reg, imm      O1 := (O2 != O3)
</pre>
</div>
<div class="section" id="conversions">
<h3>Conversions</h3>
<p>Register for integer and floating-pint values are independent and in order to convert value from one type to another you have to use one of the following operations.</p>
<pre class="literal-block">
extr    freg, reg        O1 := O2
truncr  reg, freg        O1 := trunc(O2)
ceilr   reg, freg        O1 := ceil(O2)
floorr  reg, freg        O1 := floor(O2)
roundr  reg, freg        O1 := round(O2)
</pre>
<p>The operation <tt class="docutils literal">truncr</tt> rounds the value towards zero and is the fastest one. Operations <tt class="docutils literal">floorr</tt> and <tt class="docutils literal">ceilr</tt> rounds the value towards negative or positive infinity, respectively. <tt class="docutils literal">roundr</tt> rounds the given value to the nearest integer.</p>
</div>
<div class="section" id="function-declaration">
<h3>Function declaration</h3>
<p>The following operations and auxiliary macros help to create a function, read its arguments, and return value.</p>
<ul>
<li><p class="first">Operation <tt class="docutils literal">prolog imm</tt> has one operand which is an immediate value, which is a reference to a pointer of the function defined by the intermediate code. In other words, MyJIT generates machine code for a function which resides somewhere in the memory. The address of the functions is handed by this reference. See the &quot;Getting started&quot; section, for more details and for an illustrative example.</p>
</li>
<li><p class="first">Operations <tt class="docutils literal">retr reg</tt>, <tt class="docutils literal">reti imm</tt>, <tt class="docutils literal">fretr freg, fsize</tt>, and <tt class="docutils literal">freti freg, fsize</tt> set the return value and return control to the calling procedure (or function).</p>
</li>
<li><p class="first">Operation <tt class="docutils literal">declare_arg imm, imm</tt> is not an actual operation but rather an auxiliary function which declares the type of the argument and its size (in this order); <tt class="docutils literal">declare_arg</tt> can take the following types of arguments</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">JIT_SIGNED_NUM</tt> -- signed integer number</li>
<li><tt class="docutils literal">JIT_UNSIGNED_NUM</tt> -- unsigned integer number</li>
<li><tt class="docutils literal">JIT_FLOAT</tt> -- floating-point number</li>
<li><tt class="docutils literal">JIT_PTR</tt> -- pointer</li>
</ul>
</blockquote>
</li>
<li><p class="first">To read an argument there are <tt class="docutils literal">getarg reg, imm</tt> and <tt class="docutils literal">getarg freg, imm</tt> operations having two arguments. The destination register where the input argument will be stored and the immediate value which identifies position of the argument.</p>
</li>
<li><p class="first">Operation <tt class="docutils literal">allocai imm</tt> reserves space on the stack which has at least the size specified by its operand. Note that the stack space may be aligned to some higher value. The macro returns an integer number which is an <em>offset from the frame pointer R_FP!</em></p>
</li>
</ul>
</div>
<div class="section" id="function-calls">
<h3>Function calls</h3>
<p>Each function call is done in three steps. The call is initiated by the operation <tt class="docutils literal">prepare</tt> having no argument. In the second step, arguments are passed to a function using <tt class="docutils literal">putarg</tt> or <tt class="docutils literal">fputarg</tt>. (The arguments are passed in the normal order not in reverse, cf. GNU Lightning.) Afterwards, the function is called with the <tt class="docutils literal">call</tt> operation. To retrieve the returned value you can use operations <tt class="docutils literal">retval</tt> or <tt class="docutils literal">fretval</tt>.</p>
<p>Let us make few notes on function calls:</p>
<ul class="simple">
<li>If calling a function defined in the same instance of the compiler (e.g., recursive function), you cannot pass values through registers. Each function has its own set of registers.</li>
<li>Only <tt class="docutils literal">putargr</tt>, <tt class="docutils literal">putargi</tt>, <tt class="docutils literal">fputargr</tt>, and <tt class="docutils literal">fputargi</tt> operations are allowed inside the <tt class="docutils literal"><span class="pre">prepare-call</span></tt> block, otherwise, the behavior of the library is unspecified.</li>
</ul>
<p>List of operations related to function calls:</p>
<ul class="simple">
<li><tt class="docutils literal">prepare</tt> -- prepares function call (generic)</li>
<li><tt class="docutils literal">putargr reg</tt> -- passes an argument to a function</li>
<li><tt class="docutils literal">putargi imm</tt> -- passes an argument to a function</li>
<li><tt class="docutils literal">fputargr freg, fsize</tt> -- passes the argument to a function</li>
<li><tt class="docutils literal">fputargi fimm, fsize</tt> -- passes the argument to a function</li>
<li><tt class="docutils literal">call imm</tt> -- calls a function</li>
<li><tt class="docutils literal">callr reg</tt></li>
<li><tt class="docutils literal">retval reg</tt> -- reads return value</li>
<li><tt class="docutils literal">fretval freg, fsize</tt> -- reads return value</li>
</ul>
</div>
<div class="section" id="jumps">
<h3>Jumps</h3>
<p>Operations <tt class="docutils literal">jmpi</tt> and <tt class="docutils literal">jmpr</tt> can be used to implement unconditional jumps. Both operations have one operand, an address to jump to. To obtain this address you can use the <tt class="docutils literal">get_label</tt> operation or use the forward declaration along with the <tt class="docutils literal">patch</tt> operation.</p>
<ul class="simple">
<li><tt class="docutils literal">get_label</tt> is not an actual operation; it is a function that returns a <tt class="docutils literal">jit_label</tt> value---value which corresponds to the current position in the code. This value can be passed to jmpi/call or to a branch operation.</li>
<li>It may happen that one need to jump into a code which will be defined later. Therefore, one can use the forward declaration and set the address later. This means, one can declare that the operation <tt class="docutils literal">jmpi</tt> or a branch operations jumps to the place defined by the JIT_FORWARD macro and store the pointer to the operation into some <tt class="docutils literal">jit_op *</tt> value. To set the address later, there is the <tt class="docutils literal">patch imm</tt> operation with an argument which is the patched operation. The following code illustrates the situation.</li>
</ul>
<pre class="literal-block">
op = jmpi JIT_FORWARD
     ;
     ; some code
     ;
     patch op
</pre>
</div>
<div class="section" id="branch-operations">
<h3>Branch Operations</h3>
<p>Branch operations represent conditional jumps and all have three operands. The first operand is an immediate value and represents the address to jump to. The latter two are values to be compared. The last operand can be either an immediate value or register.</p>
<pre class="literal-block">
bltr      imm, reg, reg       if (O2 &lt;  O3) goto O1
blti      imm, reg, imm       if (O2 &lt;  O3) goto O1
bltr_u    imm, reg, reg       if (O2 &lt;  O3) goto O1
blti_u    imm, reg, imm       if (O2 &lt;  O3) goto O1

bler      imm, reg, reg       if (O2 &lt;= O3) goto O1
blei      imm, reg, imm       if (O2 &lt;= O3) goto O1
bler_u    imm, reg, reg       if (O2 &lt;= O3) goto O1
blei_u    imm, reg, imm       if (O2 &lt;= O3) goto O1

bgtr      imm, reg, reg       if (O2 &gt;  O3) goto O1
bgti      imm, reg, imm       if (O2 &gt;  O3) goto O1
bgtr_u    imm, reg, reg       if (O2 &gt;  O3) goto O1
bgti_u    imm, reg, imm       if (O2 &gt;  O3) goto O1

bger      imm, reg, reg       if (O2 &gt;= O3) goto O1
bgei      imm, reg, imm       if (O2 &gt;= O3) goto O1
bger_u    imm, reg, reg       if (O2 &gt;= O3) goto O1
bgei_u    imm, reg, imm       if (O2 &gt;= O3) goto O1

beqr      imm, reg, reg       if (O2 == O3) goto O1
beqi      imm, reg, imm       if (O2 == O3) goto O1
bner      imm, reg, reg       if (O2 != O3) goto O1
bnei      imm, reg, imm       if (O2 != O3) goto O1

bmsr      imm, reg, reg       if (O2 &amp;  O3) goto O1
bmsi      imm, reg ,imm       if (O2 &amp;  O3) goto O1
bmcr      imm, reg ,reg       if !(O2 &amp; O3) goto O1
bmci      imm, reg ,imm       if !(O2 &amp; O3) goto O1

boaddr    imm, reg, reg       O2 += O3, goto O1 on overflow
boaddi    imm, reg, imm       O2 += O3, goto O1 on overflow
bnoaddr   imm, reg, reg       O2 += O3, goto O1 on not overflow
bnoaddi   imm, reg, imm       O2 += O3, goto O1 on not overflow

bosubr    imm, reg, reg       O2 -= O3, goto O1 on overflow
bosubi    imm, reg, imm       O2 -= O3, goto O1 on overflow
bnosubr   imm, reg, reg       O2 -= O3, goto O1 on not overflow
bnosubi   imm, reg, imm       O2 -= O3, goto O1 on not overflow

fbltr     imm, freg, freg     if (O2 &lt;  O3) goto O1
fblti     imm, freg, fimm     if (O2 &lt;  O3) goto O1
fbler     imm, freg, freg     if (O2 &lt;= O3) goto O1
fblei     imm, freg, fimm     if (O2 &lt;= O3) goto O1

fbgtr     imm, freg, freg     if (O2 &gt;  O3) goto O1
fbgti     imm, freg, fimm     if (O2 &gt;  O3) goto O1
fbger     imm, freg, freg     if (O2 &gt;= O3) goto O1
fbgei     imm, freg, fimm     if (O2 &gt;= O3) goto O1

fbeqr     imm, freg, freg     if (O2 == O3) goto O1
fbeqi     imm, freg, fimm     if (O2 == O3) goto O1
fbner     imm, freg, freg     if (O2 != O3) goto O1
fbnei     imm, freg, fimm     if (O2 != O3) goto O1
</pre>
</div>
<div class="section" id="misc">
<h3>Misc</h3>
<p>There is an operation that allows to emit raw bytes of data into a generated code:</p>
<pre class="literal-block">
data_byte imm
</pre>
<p>This operation emits only one byte to a generated code. For convenience there are auxiliary macros emitting a sequence of bytes, string of chars (including the trailing 0), empty area, and values of common sizes, respectively.</p>
<pre class="literal-block">
jit_data_bytes(struct jit *jit, int count, unsigned char *data)
jit_data_str(jit, str)
jit_data_emptyarea(jit, size)
jit_data_word(jit, a)
jit_data_dword(jit, a)
jit_data_qword(jit, a)
</pre>
<p>If you are emitting raw data into a code, it is your responsibility to properly align code. For this purpose there is an operation:</p>
<pre class="literal-block">
jit_align imm
</pre>
<p>This operation takes care of proper code alignment. Note that particular platforms have their specific requirements. On SPARC all instructions have to be aligned to 4 bytes, AMD64 favors alignment to 16 bytes, but it is not mandatory, etc. Safe bet is to use 16 as an operand of this operation.</p>
<p>To obtain reference to a data or code you can use two operations:</p>
<pre class="literal-block">
ref_data reg, imm
ref_code reg, imm
</pre>
<p>That loads address of the label (second operand) into a register. The ref_data operation is intended for addresses of data (emitted with data_* operations) and ref_code is for address within an ordinary code. Note that address obtained with ref_code can be used only for local jumps inside a function. If necessary, for instance, if a some sort of branch table is needed, it is possible to emit address as a data with two operations.</p>
<pre class="literal-block">
data_code imm
data_data imm
</pre>
<p>Note that mixing code and data may not be a generally good idea and may lead to various issues, e.g. poor performance, weird behavior, etc. Albeit this feature is part of the library, users are encouraged to place data to some specific part of code (for instance, to the end of code) or use data that are not part of the code and are allocated elsewhere, for instance, with ordinary <tt class="docutils literal">malloc</tt>.</p>
</div>
</div>
</div>
<div class="section" id="getting-started">
<h1>Getting Started</h1>
<p>We start with a really simple example---function returning its argument incremented by one. The source code of this example can be found in <tt class="docutils literal">demo1.c</tt> which is part of the MyJIT package.</p>
<pre class="code c literal-block">
<span class="comment preproc">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="comment single">// includes the header file
</span><span class="comment preproc">#include &quot;myjit/jitlib.h&quot;
</span>
<span class="comment single">// pointer to a function accepting one argument of type long and returning long value
</span><span class="keyword">typedef</span> <span class="name function">long</span> <span class="punctuation">(</span><span class="operator">*</span> <span class="name">plfl</span><span class="punctuation">)(</span><span class="keyword type">long</span><span class="punctuation">);</span>

<span class="keyword type">int</span> <span class="name function">main</span><span class="punctuation">()</span>
<span class="punctuation">{</span>
        <span class="comment single">// creates a new instance of the compiler
</span>        <span class="keyword">struct</span> <span class="name">jit</span> <span class="operator">*</span> <span class="name">p</span> <span class="operator">=</span> <span class="name">jit_init</span><span class="punctuation">();</span>

        <span class="name">plfl</span> <span class="name">foo</span><span class="punctuation">;</span>

        <span class="comment single">// the code generated by the compiler will be assigned to the function `foo'
</span>        <span class="name">jit_prolog</span><span class="punctuation">(</span><span class="name">p</span><span class="punctuation">,</span> <span class="operator">&amp;</span><span class="name">foo</span><span class="punctuation">);</span>

        <span class="comment single">// the first argument of the function
</span>        <span class="name">jit_declare_arg</span><span class="punctuation">(</span><span class="name">p</span><span class="punctuation">,</span> <span class="name">JIT_SIGNED_NUM</span><span class="punctuation">,</span> <span class="keyword">sizeof</span><span class="punctuation">(</span><span class="keyword type">long</span><span class="punctuation">));</span>

        <span class="comment single">// moves the first argument into the register R(0)
</span>        <span class="name">jit_getarg</span><span class="punctuation">(</span><span class="name">p</span><span class="punctuation">,</span> <span class="name">R</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">),</span> <span class="literal number integer">0</span><span class="punctuation">);</span>

        <span class="comment single">// takes the value in R(0), increments it by one, and stores the result into the
</span>        <span class="comment single">// register R(1)
</span>        <span class="name">jit_addi</span><span class="punctuation">(</span><span class="name">p</span><span class="punctuation">,</span> <span class="name">R</span><span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">),</span> <span class="name">R</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">),</span> <span class="literal number integer">1</span><span class="punctuation">);</span>

        <span class="comment single">// returns from the function and returns the value stored in the register R(1)
</span>        <span class="name">jit_retr</span><span class="punctuation">(</span><span class="name">p</span><span class="punctuation">,</span> <span class="name">R</span><span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">));</span>

        <span class="comment single">// compiles the above defined code
</span>        <span class="name">jit_generate_code</span><span class="punctuation">(</span><span class="name">p</span><span class="punctuation">);</span>

        <span class="comment single">// checks, if it works
</span>        <span class="name">printf</span><span class="punctuation">(</span><span class="literal string">&quot;Check #1: %li</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="name">foo</span><span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">));</span>
        <span class="name">printf</span><span class="punctuation">(</span><span class="literal string">&quot;Check #2: %li</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="name">foo</span><span class="punctuation">(</span><span class="literal number integer">100</span><span class="punctuation">));</span>
        <span class="name">printf</span><span class="punctuation">(</span><span class="literal string">&quot;Check #3: %li</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="name">foo</span><span class="punctuation">(</span><span class="literal number integer">255</span><span class="punctuation">));</span>

        <span class="comment single">// if you are interested, you can dump the machine code
</span>        <span class="comment single">// this functionality is provided through the `gcc' and `objdump'
</span>        <span class="comment single">// jit_dump_ops(p, JIT_DEBUG_CODE);
</span>
        <span class="comment single">// cleanup
</span>        <span class="name">jit_free</span><span class="punctuation">(</span><span class="name">p</span><span class="punctuation">);</span>
        <span class="keyword">return</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
</pre>
<p>We assume that the code above is quite (self-)explanatory, and thus, we do not include more comments on this. However, let us make a note on compiling programs using MyJIT. To start with MyJIT, it is sufficient to copy the <tt class="docutils literal">myjit</tt> subdirectory into your project. Programs using the MyJIT should include the <tt class="docutils literal">#include &quot;myjit/jitlib.h&quot;</tt> header file. In order to link the application and build a proper executable file, it is necessary to also compile <tt class="docutils literal"><span class="pre">&quot;myjit/libjit-core.c&quot;</span></tt>.</p>
<p>For instance, to build a program with <tt class="docutils literal">gcc</tt> you may use the following steps:</p>
<pre class="code bash literal-block">
gcc -c -g -Winline -Wall -std<span class="operator">=</span>c99 -pedantic -D_XOPEN_SOURCE<span class="operator">=</span>600 demo1.c
gcc -c -g -Winline -Wall -std<span class="operator">=</span>c99 -pedantic -D_XOPEN_SOURCE<span class="operator">=</span>600 myjit/jitlib-core.c
gcc -o demo1 -g -Wall -std<span class="operator">=</span>c99 -pedantic demo1.o jitlib-core.o
</pre>
<p>The first command compiles the example, the second one compiles functions used by MyJIT, and the last one links the object files together and creates an execute file---<tt class="docutils literal">demo1</tt>.</p>
<p>It should be emphasized that MyJIT conforms to the C99 standard and all MyJIT files should be compiled according to this standard.</p>
<p>We also recommend to check out the <tt class="docutils literal">demo2.c</tt> and <tt class="docutils literal">demo3.c</tt> examples which are also included in the MyJIT package.</p>
</div>
<div class="section" id="debugging">
<h1>Debugging</h1>
<div class="section" id="debugging-messages">
<h2>Debugging messages</h2>
<p>MyJIT contains several tools simplifying development. One of them is the <tt class="docutils literal">msg</tt> operation which prints out the given message or a value of the given register. The <tt class="docutils literal">msg</tt> operation has one or two operands. The first one is always an immediate value which is the string to display. The second operand is optional and it must be a register. In this case the first string serves as the format string for <tt class="docutils literal">printf</tt> and the value of the register is printed out using this string. The example of the <tt class="docutils literal">msg</tt> operation usage:</p>
<pre class="code c literal-block">
<span class="name">jit_msg</span><span class="punctuation">(</span><span class="name">jit</span><span class="punctuation">,</span> <span class="literal string">&quot;Simple message</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">);</span>
<span class="name">jit_msgr</span><span class="punctuation">(</span><span class="name">jit</span><span class="punctuation">,</span> <span class="literal string">&quot;Reg 1: %l</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="name">R</span><span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">));</span>
</pre>
</div>
<div class="section" id="warnings">
<h2>Warnings</h2>
<p>One of the MyJIT's goals is to achieve maximal performance while emitting code. Thus, it does not do many checks while generating machine code from the intermediate language. Therefore, if the code in the intermediate language contains an error, it leads to a faulty machine code, and subsequently to a crash of the program. In order to avoid such errors, MyJIT contains a function:</p>
<pre class="code c literal-block">
<span class="keyword type">void</span> <span class="name function">jit_check_code</span><span class="punctuation">(</span><span class="keyword">struct</span> <span class="name">jit</span> <span class="operator">*</span><span class="name">jit</span><span class="punctuation">,</span> <span class="keyword type">int</span> <span class="name">warnings</span><span class="punctuation">);</span>
</pre>
<p>Which can be called before code generation and which can point out to the most common errors. In the second argument you may specify if you want to be warned about all types of errors (<tt class="docutils literal">JIT_WARN_ALL</tt>) or you can pick only some of them from the following list:</p>
<ul class="simple">
<li><tt class="docutils literal">JIT_WARN_DEAD_CODE</tt> -- detects unreachable code</li>
<li><tt class="docutils literal">JIT_WARN_OP_WITHOUT_EFFECT</tt> -- displays warnings about operations without effect</li>
<li><tt class="docutils literal">JIT_WARN_INVALID_DATA_SIZE</tt> -- displays warning if the size operand does not contain a valid value (i.e., 1, 2, 4, or 8)</li>
<li><tt class="docutils literal">JIT_WARN_UNINITIALIZED_REG</tt> -- displays warning if an uninitialized register is used</li>
<li><tt class="docutils literal">JIT_WARN_REGISTER_TYPE_MISMATCH</tt> -- displays warning if a general purpose register is used in place where the floating point register is expected, or vice versa</li>
<li><tt class="docutils literal">JIT_WARN_MISSING_PATCH</tt> -- reports all jump operations with a <tt class="docutils literal">JIT_FORWARD</tt> declaration but without corresponding <tt class="docutils literal">patch</tt></li>
<li><tt class="docutils literal">JIT_WARN_UNALIGNED_CODE</tt> -- displays warning if the code follows data section without alignment</li>
<li><tt class="docutils literal">JIT_WARN_INVALID_CODE_REFERENCE</tt> -- displays warning if <tt class="docutils literal">ref_code</tt> or <tt class="docutils literal">data_code</tt> is referring to a data and not to a valid code</li>
<li><tt class="docutils literal">JIT_WARN_INVALID_DATA_REFERENCE</tt> -- displays warning if <tt class="docutils literal">ref_data</tt> or <tt class="docutils literal">data_data</tt> is referring to a code and not to a data</li>
<li><tt class="docutils literal">JIT_WARN_ALL</tt> -- displays all warnings</li>
</ul>
</div>
<div class="section" id="code-listing">
<h2>Code listing</h2>
<p>In real programs is MyJIT typically called from various functions and code is constructed in several steps, thus it is sometimes difficult to figure out, how the code looks like. Therefore, MyJIT provides several means allowing to inspect final code in the intermediate language as well as in the machine code. This functionality is provided through the <tt class="docutils literal">jit_dump_ops</tt> function. In the second argument you may specify if you want to list:</p>
<ul class="simple">
<li>list of all operations in the intermediate language (<tt class="docutils literal">JIT_DEBUG_OPS</tt>)</li>
<li>generated machine code (<tt class="docutils literal">JIT_DEBUG_CODE</tt>)</li>
<li>combination of both -- MyJIT operations and machine code (<tt class="docutils literal">JIT_DEBUG_COMBINED</tt>)</li>
</ul>
<p>To make the navigation through the listing easier, we have included one auxiliary operation:</p>
<pre class="literal-block">
comment imm
</pre>
<p>Which has only one argument -- string which will appear only in the dumps.</p>
<p><em>NOTICE!</em> Do not use debugging operations and functions in the production code. These operations are not efficient and may lead to a poor performance. You should rather call the <tt class="docutils literal">printf</tt> function explicitly. The <tt class="docutils literal">jit_dump_ops</tt> with the <tt class="docutils literal">JIT_DEBUG_CODE</tt> is using <tt class="docutils literal">gcc</tt> and <tt class="docutils literal">objdump</tt> to disassemble the code, therefore, these two programs have to be present in the system, or, on OS X <tt class="docutils literal">clang</tt> and <tt class="docutils literal">otool</tt> are used. The <tt class="docutils literal">JIT_DEBUG_COMBINED</tt> option requires <tt class="docutils literal"><span class="pre">myjit-disasm</span></tt> disassembler in the directory along with the debugged program, or the path to the disassembler has to be specified in the <tt class="docutils literal">MYJIT_DISASM</tt> environment variable.</p>
<p>Examples of the outputs for the above mentioned source code.</p>
<div class="section" id="example-of-the-il-listing-jit-debug-ops">
<h3>Example of the IL listing (<tt class="docutils literal">JIT_DEBUG_OPS</tt>)</h3>
<pre class="literal-block">
prolog      0xbfe62858
declarg     integer, 0x4
getarg      r0, 0x0
addi        r1, r0, 0x1
retr        r1
</pre>
</div>
<div class="section" id="example-of-the-machine-code-listing-jit-debug-code">
<h3>Example of the machine code listing (<tt class="docutils literal">JIT_DEBUG_CODE</tt>)</h3>
<pre class="literal-block">
0000000000000000 &lt;main&gt;:
   0:   55                      push   rbp
   1:   48 8b ec                mov    rbp,rsp
   4:   48 83 ec 20             sub    rsp,0x20
   8:   48 8b f7                mov    rsi,rdi
   b:   48 8d 46 01             lea    rax,[rsi+0x1]
   f:   48 8b e5                mov    rsp,rbp
  12:   5d                      pop    rbp
  13:   c3                      ret
</pre>
</div>
<div class="section" id="example-of-the-combined-listing-jit-debug-combined">
<h3>Example of the combined listing (<tt class="docutils literal">JIT_DEBUG_COMBINED</tt>)</h3>
<pre class="literal-block">
  prolog   0x7fffa0371db0
0000: 55                         push rbp
0001: 48 8b ec                   mov rbp, rsp
0004: 48 83 ec 20                sub rsp, 0x20

  declare_arg integer, 0x8
  getarg   r0, 0x0
0008: 48 8b f7                   mov rsi, rdi

  addi     r1, r0, 0x1
000b: 48 8d 46 01                lea rax, [rsi+0x1]

  retr     r1
000f: 48 8b e5                   mov rsp, rbp
0012: 5d                         pop rbp
0013: c3                         ret
</pre>
</div>
</div>
</div>
<div class="section" id="optimizations">
<h1>Optimizations</h1>
<p>Support for multiple optimizations is available since release 0.7. These optimizations may speed up your code but the code generation may take longer. Therefore, you can turn particular optimization off and on using <tt class="docutils literal">jit_disable_optimization</tt> and <tt class="docutils literal">jit_enable_optimization</tt> functions, respectively. Currently, there are available the following optimizations:</p>
<ul class="simple">
<li><tt class="docutils literal">JIT_OPT_OMIT_UNUSED_ASSIGNEMENTS</tt> -- compiler skips unused assignments. (Turned off by default.)</li>
<li><tt class="docutils literal">JIT_OPT_JOIN_ADDMUL</tt> -- if possible, compiler joins adjacent <tt class="docutils literal">mul</tt> and <tt class="docutils literal">add</tt> (or two <tt class="docutils literal">add</tt>'s) into one <tt class="docutils literal">LEA</tt> operation (Turned on by default.)</li>
<li><tt class="docutils literal">JIT_OPT_OMIT_FRAME_PTR</tt> -- if possible, compiler skips prolog and epilogue of the function. This significantly speeds up small functions.  (Turned on by default.)</li>
</ul>
<p>The optimized code for above mentioned example looks like this:</p>
<pre class="literal-block">
00000000 &lt;main&gt;:
   0:   8b 4c 24 04             mov    ecx,DWORD PTR [esp+0x4]
   4:   8d 41 01                lea    eax,[ecx+0x1]
   7:   c3                      ret
</pre>
<p>Or, like this:</p>
<pre class="literal-block">
0000000000000000 &lt;main&gt;:
   0:   48 8d 47 01             lea    rax,[rdi+1]
   4:   c3                      ret
</pre>
</div>
<div class="section" id="download">
<h1>Download</h1>
<div class="section" id="getting-myjit">
<h2>Getting MyJIT</h2>
<p>The source code including this documentation and examples is available at SourceForge (<a class="reference external" href="http://sourceforge.net/projects/myjit/files">http://sourceforge.net/projects/myjit/files</a>) as of other information (<a class="reference external" href="http://sourceforge.net/projects/myjit">http://sourceforge.net/projects/myjit</a>)</p>
<p>You can also checkout the latest release from the GIT repository:</p>
<pre class="literal-block">
git clone git://git.code.sf.net/p/myjit/maincode myjit-maincode).
</pre>
</div>
<div class="section" id="documentation">
<h2>Documentation</h2>
<p>Documentation is available in the <tt class="docutils literal">doc/</tt> directory and on the project's website as a text file, <a class="reference external" href="http://myjit.sourceforge.net/readme.pdf">PDF file</a>, or as a <a class="reference external" href="http://myjit.sourceforge.net/readme.htm">single HTML page</a>.</p>
</div>
<div class="section" id="license">
<h2>License</h2>
<p>MyJIT is distributed under the terms of GNU Lesser General Public License v.3 or later (at your option).</p>
<p>Despite the fact that MyJIT is very similar to GNU Lightning, it does not share any source code with this project. However, some files come from the Mono project by Novel. (<a class="reference external" href="http://www.mono-project.com">http://www.mono-project.com</a>)</p>
</div>
</div>
<div class="section" id="notes-on-development">
<h1>Notes on Development</h1>
<ul class="simple">
<li>The primary use of this library is in our compiler of the Schemik programming language and the development of this library is driven by requirements of this compiler. Nevertheless, MyJIT is a general purpose library and its functionality is not limited.</li>
<li>The library is almost complete and each release undergoes extensive testing (hundreds of tests), therefore, we hope there are no serious bugs. If you found any, please, let us know.</li>
<li>Despite the fact that the library is almost complete, it is still under development and the API may slightly (but not much) change in the near future.</li>
<li>Only the i386, AMD64, and SPARC platforms are supported right now, however, port to other architecture should be easy and straightforward.</li>
<li>At this moment, MyJIT has support for floating point arithmetics. However, i386 port supports only processors having SSE2 unit, i.e., floating-point operations won't work on legacy CPUs without this unit.</li>
<li>If you are using this library or if you want to contribute some code (e.g., port to some architecture), please, let us know.</li>
<li>The documentation lacks information on internals of MyJIT. This is purely intentional because the library is still developed. We expect that the quality of the documentation will improve with the maturity of the project. If in doubts,  ask in the mailing list (<a class="reference external" href="mailto:myjit-devel&#64;lists.sourceforge.net">myjit-devel&#64;lists.sourceforge.net</a>). If you  would like to participate on documentation improvements, please let us know, we will really appreciate it.</li>
</ul>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2015-03-15 16:37 UTC.

</div>
</body>
</html>
