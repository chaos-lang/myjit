* movr                      i  ui  l  ul  p  f  d  O1 = O2
* movi                      i  ui  l  ul  p  f  d  O1 = O2

* ldr     c  uc  s  us  i  ui  l  ul  p  f  d  O1 =  O2
* ldi     c  uc  s  us  i  ui  l  ul  p  f  d  O1 =  O2
* ldxr    c  uc  s  us  i  ui  l  ul  p  f  d  O1 =  (O2+O3)
* ldxi    c  uc  s  us  i  ui  l  ul  p  f  d  O1 =  (O2+O3)

* str     c  uc  s  us  i  ui  l  ul  p  f  d   O1 = O2
* sti     c  uc  s  us  i  ui  l  ul  p  f  d   O1 = O2
* stxr    c  uc  s  us  i  ui  l  ul  p  f  d   (O1+O2) = O3
* stxi    c  uc  s  us  i  ui  l  ul  p  f  d   (O1+O2) = O3

* prepare                   i                f  d
* pusharg     c  uc  s  us  i  ui  l  ul  p  f  d
* getarg      c  uc  s  us  i  ui  l  ul  p  f  d
* arg         c  uc  s  us  i  ui  l  ul  p  f  d
* retval      c  uc  s  us  i  ui  l  ul  p

* calli     (not specified)                  function call to O1
  callr     (not specified)                  function call to a register
* finish    (not specified)                  function call to O1
* finishr   (not specified)                  function call to a register
* jmpi/jmpr (not specified)                  unconditional jump to O1
* ret/reti/retr (not specified)                  return from subroutine

* prolog    (not specified)                  function prolog for O1 args
  leaf      (not specified)                  the same for leaf functions
* allocai   (not specified)                  reserve space on the stack

* addr     i  ui  l  ul  p  f  d  O1 = O2 + O3
* addi     i  ui  l  ul  p        O1 = O2 + O3
* addxr    i  ui  l  ul           O1 = O2 + (O3 + carry)
* addxi    i  ui  l  ul           O1 = O2 + (O3 + carry)
* addcr    i  ui  l  ul           O1 = O2 + O3, set carry
* addci    i  ui  l  ul           O1 = O2 + O3, set carry
* subr     i  ui  l  ul  p  f  d  O1 = O2 - O3
* subi     i  ui  l  ul  p        O1 = O2 - O3
* subxr    i  ui  l  ul           O1 = O2 - (O3 + carry)
* subxi    i  ui  l  ul           O1 = O2 - (O3 + carry)
* subcr    i  ui  l  ul           O1 = O2 - O3, set carry
* subci    i  ui  l  ul           O1 = O2 - O3, set carry
* rsbr     i  ui  l  ul  p  f  d  O1 = O3 - O2
* rsbi     i  ui  l  ul  p        O1 = O3 - O2
* mulr     i  ui  l  ul     f  d  O1 = O2 * O3
* muli     i  ui  l  ul           O1 = O2 * O3
  hmulr    i  ui  l  ul           O1 = high bits of O2 * O3
  hmuli    i  ui  l  ul           O1 = high bits of O2 * O3
* divr     i  ui  l  ul     f  d  O1 = O2 / O3
* divi     i  ui  l  ul           O1 = O2 / O3
* modr     i  ui  l  ul           O1 = O2 % O3
* modi     i  ui  l  ul           O1 = O2 % O3
* andr     i  ui  l  ul           O1 = O2 & O3
* andi     i  ui  l  ul           O1 = O2 & O3
* orr      i  ui  l  ul           O1 = O2 | O3
* ori      i  ui  l  ul           O1 = O2 | O3
* xorr     i  ui  l  ul           O1 = O2 ^ O3
* xori     i  ui  l  ul           O1 = O2 ^ O3
* lshr     i  ui  l  ul           O1 = O2 << O3
* lshi     i  ui  l  ul           O1 = O2 << O3
* rshr     i  ui  l  ul           O1 = O2 >> O31
* rshi     i  ui  l  ul           O1 = O2 >> O32

  negr     i     l         f  d  O1 = -O2
  notr     i  ui l  ul           O1 = ~O2

* ltr      i  ui  l  ul  p  f  d  O1 = (O2 <  O3)
* lti      i  ui  l  ul  p        O1 = (O2 <  O3)
* ler      i  ui  l  ul  p  f  d  O1 = (O2 <= O3)
* lei      i  ui  l  ul  p        O1 = (O2 <= O3)
* gtr      i  ui  l  ul  p  f  d  O1 = (O2 >  O3)
* gti      i  ui  l  ul  p        O1 = (O2 >  O3)
* ger      i  ui  l  ul  p  f  d  O1 = (O2 >= O3)
* gei      i  ui  l  ul  p        O1 = (O2 >= O3)
* eqr      i  ui  l  ul  p  f  d  O1 = (O2 == O3)
* eqi      i  ui  l  ul  p        O1 = (O2 == O3)
* ner      i  ui  l  ul  p  f  d  O1 = (O2 != O3)
* nei      i  ui  l  ul  p        O1 = (O2 != O3)
- unltr                     f  d  O1 = !(O2 >= O3)
- unler                     f  d  O1 = !(O2 >  O3)
- ungtr                     f  d  O1 = !(O2 <= O3)
- unger                     f  d  O1 = !(O2 <  O3)
- uneqr                     f  d  O1 = !(O2 <  O3) && !(O2 >  O3)
- ltgtr                     f  d  O1 = !(O2 >= O3) || !(O2 <= O3)
- ordr                      f  d  O1 =  (O2 == O2) &&  (O3 == O3)
- unordr                    f  d  O1 =  (O2 != O2) ||  (O3 != O3)

- extr        c  uc  s  us  i  ui  l  ul     f  d  O1 = O2
- roundr                    i                f  d  O1 = round(O2)
- truncr                    i                f  d  O1 = trunc(O2)
- floorr                    i                f  d  O1 = floor(O2)
- ceilr                     i                f  d  O1 = ceil(O2)

* bltr      i  ui  l  ul  p  f  d  if (O2 <  O3) goto O1
* blti      i  ui  l  ul  p        if (O2 <  O3) goto O1
* bler      i  ui  l  ul  p  f  d  if (O2 <= O3) goto O1
* blei      i  ui  l  ul  p        if (O2 <= O3) goto O1
* bgtr      i  ui  l  ul  p  f  d  if (O2 >  O3) goto O1
* bgti      i  ui  l  ul  p        if (O2 >  O3) goto O1
* bger      i  ui  l  ul  p  f  d  if (O2 >= O3) goto O1
* bgei      i  ui  l  ul  p        if (O2 >= O3) goto O1
* beqr      i  ui  l  ul  p  f  d  if (O2 == O3) goto O1
* beqi      i  ui  l  ul  p        if (O2 == O3) goto O1
* bner      i  ui  l  ul  p  f  d  if (O2 != O3) goto O1
* bnei      i  ui  l  ul  p        if (O2 != O3) goto O1
 
- bunltr                     f  d  if !(O2 >= O3) goto O1
- bunler                     f  d  if !(O2 >  O3) goto O1
- bungtr                     f  d  if !(O2 <= O3) goto O1
- bunger                     f  d  if !(O2 <  O3) goto O1
- buneqr                     f  d  if !(O2 <  O3) && !(O2 >  O3) goto O1
- bltgtr                     f  d  if !(O2 >= O3) || !(O2 <= O3) goto O1
- bordr                      f  d  if  (O2 == O2) &&  (O3 == O3) goto O1
- bunordr                    f  d  if !(O2 != O2) ||  (O3 != O3) goto O1
 
  bmsr      i ui l  ul             if O2 &  O3 goto O1
  bmsi      i ui l  ul             if O2 &  O3 goto O1
  bmcr      i ui l  ul             if !(O2 & O3) goto O1
  bmci      i ui l  ul             if !(O2 & O3) goto O14
  boaddr    i ui l  ul             O2 += O3, goto O1 on overflow
  boaddi    i ui l  ul             O2 += O3, goto O1 on overflow
  bosubr    i ui l  ul             O2 -= O3, goto O1 on overflow
  bosubi    i ui l  ul             O2 -= O3, goto O1 on overflow
